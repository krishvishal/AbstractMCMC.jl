var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC defines an interface for sampling Markov chains.","category":"page"},{"location":"api/#Sampling-a-single-chain","page":"API","title":"Sampling a single chain","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.sample(::AbstractRNG, ::AbstractMCMC.AbstractModel, ::AbstractMCMC.AbstractSampler, ::Integer)\nAbstractMCMC.sample(::AbstractRNG, ::AbstractMCMC.AbstractModel, ::AbstractMCMC.AbstractSampler, ::Any)","category":"page"},{"location":"api/#StatsBase.sample-Tuple{AbstractRNG, AbstractMCMC.AbstractModel, AbstractMCMC.AbstractSampler, Integer}","page":"API","title":"StatsBase.sample","text":"sample([rng, ]model, sampler, N; kwargs...)\n\nReturn N samples from the model with the Markov chain Monte Carlo sampler.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.sample-Tuple{AbstractRNG, AbstractMCMC.AbstractModel, AbstractMCMC.AbstractSampler, Any}","page":"API","title":"StatsBase.sample","text":"sample([rng, ]model, sampler, isdone; kwargs...)\n\nSample from the model with the Markov chain Monte Carlo sampler until a convergence criterion isdone returns true, and return the samples.\n\nThe function isdone has the signature\n\nisdone(rng, model, sampler, samples, iteration; kwargs...)\n\nand should return true when sampling should end, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Iterator","page":"API","title":"Iterator","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.steps(::AbstractRNG, ::AbstractMCMC.AbstractModel, ::AbstractMCMC.AbstractSampler)","category":"page"},{"location":"api/#AbstractMCMC.steps-Tuple{AbstractRNG, AbstractMCMC.AbstractModel, AbstractMCMC.AbstractSampler}","page":"API","title":"AbstractMCMC.steps","text":"steps([rng, ]model, sampler; kwargs...)\n\nCreate an iterator that returns samples from the model with the Markov chain Monte Carlo sampler.\n\nExamples\n\njulia> struct MyModel <: AbstractMCMC.AbstractModel end\n\njulia> struct MySampler <: AbstractMCMC.AbstractSampler end\n\njulia> function AbstractMCMC.step(rng, ::MyModel, ::MySampler, state=nothing; kwargs...)\n           # all samples are zero\n           return 0.0, state\n       end\n\njulia> iterator = steps(MyModel(), MySampler());\n\njulia> collect(Iterators.take(iterator, 10)) == zeros(10)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Transducer","page":"API","title":"Transducer","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.Sample(::AbstractRNG, ::AbstractMCMC.AbstractModel, ::AbstractMCMC.AbstractSampler)","category":"page"},{"location":"api/#AbstractMCMC.Sample-Tuple{AbstractRNG, AbstractMCMC.AbstractModel, AbstractMCMC.AbstractSampler}","page":"API","title":"AbstractMCMC.Sample","text":"Sample([rng, ]model, sampler; kwargs...)\n\nCreate a transducer that returns samples from the model with the Markov chain Monte Carlo sampler.\n\nExamples\n\njulia> struct MyModel <: AbstractMCMC.AbstractModel end\n\njulia> struct MySampler <: AbstractMCMC.AbstractSampler end\n\njulia> function AbstractMCMC.step(rng, ::MyModel, ::MySampler, state=nothing; kwargs...)\n           # all samples are zero\n           return 0.0, state\n       end\n\njulia> transducer = Sample(MyModel(), MySampler());\n\njulia> collect(transducer(1:10)) == zeros(10)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Sampling-multiple-chains-in-parallel","page":"API","title":"Sampling multiple chains in parallel","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.sample(\n    ::AbstractRNG,\n    ::AbstractMCMC.AbstractModel,\n    ::AbstractMCMC.AbstractSampler,\n    ::AbstractMCMC.AbstractMCMCEnsemble,\n    ::Integer,\n    ::Integer,\n)","category":"page"},{"location":"api/#StatsBase.sample-Tuple{AbstractRNG, AbstractMCMC.AbstractModel, AbstractMCMC.AbstractSampler, AbstractMCMC.AbstractMCMCEnsemble, Integer, Integer}","page":"API","title":"StatsBase.sample","text":"sample([rng, ]model, sampler, parallel, N, nchains; kwargs...)\n\nSample nchains Monte Carlo Markov chains from the model with the sampler in parallel using the parallel algorithm, and combine them into a single chain.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Two algorithms are provided for parallel sampling with multiple threads and multiple processes, and one allows for the user to sample multiple chains in serial (no parallelization):","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.MCMCThreads\nAbstractMCMC.MCMCDistributed\nAbstractMCMC.MCMCSerial","category":"page"},{"location":"api/#AbstractMCMC.MCMCThreads","page":"API","title":"AbstractMCMC.MCMCThreads","text":"MCMCThreads\n\nThe MCMCThreads algorithm allows users to sample MCMC chains in parallel using multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractMCMC.MCMCDistributed","page":"API","title":"AbstractMCMC.MCMCDistributed","text":"MCMCDistributed\n\nThe MCMCDistributed algorithm allows users to sample MCMC chains in parallel using multiple processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractMCMC.MCMCSerial","page":"API","title":"AbstractMCMC.MCMCSerial","text":"MCMCSerial\n\nThe MCMCSerial algorithm allows users to sample serially, with no thread or process parallelism.\n\n\n\n\n\n","category":"type"},{"location":"api/#Common-keyword-arguments","page":"API","title":"Common keyword arguments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Common keyword arguments for regular and parallel sampling (not supported by the iterator and transducer) are:","category":"page"},{"location":"api/","page":"API","title":"API","text":"progress (default: AbstractMCMC.PROGRESS[] which is true initially):  toggles progress logging\nchain_type (default: Any): determines the type of the returned chain\ncallback (default: nothing): if callback !== nothing, then callback(rng, model, sampler, sample, iteration) is called after every sampling step, where sample is the most recent sample of the Markov chain and iteration is the current iteration\ndiscard_initial (default: 0): number of initial samples that are discarded\nthinning (default: 1): factor by which to thin samples.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Progress logging can be enabled and disabled globally with AbstractMCMC.setprogress!(progress).","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.setprogress!","category":"page"},{"location":"api/#AbstractMCMC.setprogress!","page":"API","title":"AbstractMCMC.setprogress!","text":"setprogress!(progress::Bool)\n\nEnable progress logging globally if progress is true, and disable it otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chains","page":"API","title":"Chains","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The chain_type keyword argument allows to set the type of the returned chain. A common choice is to return chains of type Chains from MCMCChains.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC defines the abstract type AbstractChains for Markov chains.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.AbstractChains","category":"page"},{"location":"api/#AbstractMCMC.AbstractChains","page":"API","title":"AbstractMCMC.AbstractChains","text":"AbstractChains\n\nAbstractChains is an abstract type for an object that stores parameter samples generated through a MCMC process.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"For chains of this type, AbstractMCMC defines the following two methods.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.chainscat\nAbstractMCMC.chainsstack","category":"page"},{"location":"api/#AbstractMCMC.chainscat","page":"API","title":"AbstractMCMC.chainscat","text":"chainscat(c::AbstractChains...)\n\nConcatenate multiple chains.\n\nBy default, the chains are concatenated along the third dimension by calling cat(c...; dims=3).\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractMCMC.chainsstack","page":"API","title":"AbstractMCMC.chainsstack","text":"chainsstack(c::AbstractVector)\n\nStack chains in c.\n\nBy default, the vector of chains is returned unmodified. If eltype(c) <: AbstractChains, then reduce(chainscat, c) is called.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interacting-with-states-of-samplers","page":"API","title":"Interacting with states of samplers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"To make it a bit easier to interact with some arbitrary sampler state, we encourage implementations of AbstractSampler to implement the following methods:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.realize\nAbstractMCMC.realize!!","category":"page"},{"location":"api/#AbstractMCMC.realize","page":"API","title":"AbstractMCMC.realize","text":"realize(transition)\n\nReturn the realization of the random variables present in transition.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractMCMC.realize!!","page":"API","title":"AbstractMCMC.realize!!","text":"realize!!(state, realization)\n\nUpdate the realization of the state with realization and return it.\n\nIf state can be updated in-place, it is expected that this function returns state with updated realize. Otherwise a new state object with the new realization is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"and optionally","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractMCMC.updatestate!!(state, transition, state_prev)","category":"page"},{"location":"api/#AbstractMCMC.updatestate!!-Tuple{Any, Any, Any}","page":"API","title":"AbstractMCMC.updatestate!!","text":"updatestate!!(state, transition_prev[, state_prev])\n\nReturn new instance of state using information from transition_prev and, optionally, state_prev.\n\nDefaults to realize!!(state, realize(transition_prev)).\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"These methods can also be useful for implementing samplers which wraps some inner samplers, e.g. a mixture of samplers.","category":"page"},{"location":"api/#Example:-MixtureSampler","page":"API","title":"Example: MixtureSampler","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In a MixtureSampler we need two things:","category":"page"},{"location":"api/","page":"API","title":"API","text":"components: collection of samplers.\nweights: collection of weights representing the probability of chosing the corresponding sampler.","category":"page"},{"location":"api/","page":"API","title":"API","text":"struct MixtureSampler{W,C} <: AbstractMCMC.AbstractSampler\n    components::C\n    weights::W\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"To implement the state, we need to keep track of a couple of things:","category":"page"},{"location":"api/","page":"API","title":"API","text":"index: the index of the sampler used in this step.\ntransition: the transition resulting from this step.\nstates: the current states of all the components.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Two aspects of this might seem a bit strange:","category":"page"},{"location":"api/","page":"API","title":"API","text":"We need to keep track of the states of all components rather than just the state for the sampler we used previously.\nWe need to put the transition from the step into the state.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The reason for (1) is that lots of samplers keep track of more than just the previous realizations of the variables, e.g. in AdvancedHMC.jl we keep track of the momentum used, the metric used, etc.","category":"page"},{"location":"api/","page":"API","title":"API","text":"For (2) the reason is similar: some samplers might keep track of the variables in the state differently, e.g. you might have a sampler which is independent of the current realizations and the state is simply nothing. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hence, we need the transition, which should always contain the realizations, to make sure we can resume from the same point in the space in the next step.","category":"page"},{"location":"api/","page":"API","title":"API","text":"struct MixtureState{T,S}\n    index::Int\n    transition::T\n    states::S\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"The step for a MixtureSampler is defined by the following generative process","category":"page"},{"location":"api/","page":"API","title":"API","text":"beginaligned\ni sim mathrmCategorical(w_1 dots w_k) \nX_t sim mathcalK_i(cdot mid X_t - 1)\nendaligned","category":"page"},{"location":"api/","page":"API","title":"API","text":"where mathcalK_i denotes the i-th kernel/sampler, and w_i denotes the weight/probability of choosing the i-th sampler. AbstractMCMC.updatestate!! comes into play in defining/computing mathcalK_i(cdot mid X_t - 1) since X_t - 1 could be coming from a different sampler. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If we let state be the current MixtureState, i the current component, and i_prev is the previous component we sampled from, then this translates into the following piece of code:","category":"page"},{"location":"api/","page":"API","title":"API","text":"# Update the corresponding state, i.e. `state.states[i]`, using\n# the state and transition from the previous iteration.\nstate_current = AbstractMCMC.updatestate!!(\n    state.states[i], state.states[i_prev], state.transition\n)\n\n# Take a `step` for this sampler using the updated state.\ntransition, state_current = AbstractMCMC.step(\n    rng, model, sampler_current, sampler_state;\n    kwargs...\n)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The full AbstractMCMC.step implementation would then be something like:","category":"page"},{"location":"api/","page":"API","title":"API","text":"function AbstractMCMC.step(rng, model::AbstractMCMC.AbstractModel, sampler::MixtureSampler, state; kwargs...)\n    # Sample the component to use in this `step`.\n    i = rand(Categorical(sampler.weights))\n    sampler_current = sampler.components[i]\n\n    # Update the corresponding state, i.e. `state.states[i]`, using\n    # the state and transition from the previous iteration.\n    i_prev = state.index\n    state_current = AbstractMCMC.updatestate!!(\n        state.states[i], state.states[i_prev], state.transition\n    )\n\n    # Take a `step` for this sampler using the updated state.\n    transition, state_current = AbstractMCMC.step(\n        rng, model, sampler_current, state_current;\n        kwargs...\n    )\n\n    # Create the new states.\n    # NOTE: Code below will result in `states_new` being a `Vector`.\n    # If we wanted to allow usage of alternative containers, e.g. `Tuple`,\n    # it would be better to use something like `@set states[i] = state_current`\n    # where `@set` is from Setfield.jl.\n    states_new = map(1:length(state.states)) do j\n        if j == i\n            # Replace the i-th state with the new one.\n            state_current\n        else\n            # Otherwise we just carry over the previous ones.\n            state.states[j]\n        end\n    end\n\n    # Create the new `MixtureState`.\n    state_new = MixtureState(i, transition, states_new)\n\n    return transition, state_new\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"And for the initial AbstractMCMC.step we have:","category":"page"},{"location":"api/","page":"API","title":"API","text":"function AbstractMCMC.step(rng, model::AbstractMCMC.AbstractModel, sampler::MixtureSampler; kwargs...)\n    # Initialize every state.\n    transitions_and_states = map(sampler.components) do spl\n        AbstractMCMC.step(rng, model, spl; kwargs...)\n    end\n\n    # Sample the component to use this `step`.\n    i = rand(Categorical(sampler.weights))\n    # Extract the corresponding transition.\n    transition = first(transitions_and_states[i])\n    # Extract states.\n    states = map(last, transitions_and_states)\n    # Create new `MixtureState`.\n    state = MixtureState(i, transition, states)\n\n    return transition, state\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"Suppose we then wanted to use this with some of the packages which implements AbstractMCMC.jl's interface, e.g. AdvancedMH.jl, then we'd simply have to implement realize and realize!!:","category":"page"},{"location":"api/","page":"API","title":"API","text":"function AbstractMCMC.updatestate!!(::AdvancedMH.Transition, state_prev::AdvancedMH.Transition)\n    # Let's `deepcopy` just to be certain.\n    return deepcopy(state_prev)\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"To use MixtureSampler with two samplers sampler1 and sampler2 from AdvancedMH.jl as components, we'd simply do","category":"page"},{"location":"api/","page":"API","title":"API","text":"sampler = MixtureSampler([sampler1, sampler2], [0.1, 0.9])\ntransition, state = AbstractMCMC.step(rng, model, sampler)\nwhile ...\n    transition, state = AbstractMCMC.step(rng, model, sampler, state)\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"As a final note, there is one potential issue we haven't really addressed in the above implementation: a lot of samplers have their own implementations of AbstractMCMC.AbstractModel which means that we would also have to ensure that all the different samplers we are using would be compatible with the same model. A very easy way to fix this would be to just add a struct called ManyModels supporting getindex, e.g. models[i] would return the i-th model:","category":"page"},{"location":"api/","page":"API","title":"API","text":"struct ManyModels{M} <: AbstractMCMC.AbstractModel\n    models::M\nend\n\nBase.getindex(model::ManyModels, I...) = model.models[I...]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Then the above step would just extract the model corresponding to the current sampler:","category":"page"},{"location":"api/","page":"API","title":"API","text":"# Take a `step` for this sampler using the updated state.\ntransition, state_current = AbstractMCMC.step(\n    rng, model[i], sampler_current, state_current;\n    kwargs...\n)","category":"page"},{"location":"api/","page":"API","title":"API","text":"This issue should eventually disappear as the community moves towards a unified approach to implement AbstractMCMC.AbstractModel.","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"This page explains the default implementations and design choices of AbstractMCMC. It is not intended for users but for developers that want to implement the AbstractMCMC interface for Markov chain Monte Carlo sampling. The user-facing API is explained in API.","category":"page"},{"location":"design/#Overview","page":"Design","title":"Overview","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"AbstractMCMC provides a default implementation of the user-facing interface described in API. You can completely neglect these and define your own implementation of the interface. However, as described below, in most use cases the default implementation allows you to obtain support of parallel sampling, progress logging, callbacks, iterators, and transducers for free by just defining the sampling step of your inference algorithm, drastically reducing the amount of code you have to write. In general, the docstrings of the functions described below might be helpful if you intend to make use of the default implementations.","category":"page"},{"location":"design/#Basic-structure","page":"Design","title":"Basic structure","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The simplified structure for regular sampling (the actual implementation contains some additional error checks and support for progress logging and callbacks) is","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"StatsBase.sample(\n    rng::Random.AbstractRNG,\n    model::AbstractMCMC.AbstractModel,\n    sampler::AbstractMCMC.AbstractSampler,\n    nsamples::Integer;\n    chain_type = ::Type{Any},\n    kwargs...\n)\n    # Obtain the initial sample and state.\n    sample, state = AbstractMCMC.step(rng, model, sampler; kwargs...)\n\n    # Save the sample.\n    samples = AbstractMCMC.samples(sample, model, sampler, N; kwargs...)\n    samples = AbstractMCMC.save!!(samples, sample, 1, model, sampler, N; kwargs...)\n\n    # Step through the sampler.\n    for i in 2:N\n        # Obtain the next sample and state.\n        sample, state = AbstractMCMC.step(rng, model, sampler, state; kwargs...)\n\n        # Save the sample.\n        samples = AbstractMCMC.save!!(samples, sample, i, model, sampler, N; kwargs...)\n    end\n\n    return AbstractMCMC.bundle_samples(samples, model, sampler, state, chain_type; kwargs...)\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"All other default implementations make use of the same structure and in particular call the same methods.","category":"page"},{"location":"design/#Sampling-step","page":"Design","title":"Sampling step","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The only method for which no default implementation is provided (and hence which downstream packages have to implement) is AbstractMCMC.step. It defines the sampling step of the inference method.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"AbstractMCMC.step","category":"page"},{"location":"design/#AbstractMCMC.step","page":"Design","title":"AbstractMCMC.step","text":"step(rng, model, sampler[, state; kwargs...])\n\nReturn a 2-tuple of the next sample and the next state of the MCMC sampler for model.\n\nSamples describe the results of a single step of the sampler. As an example, a sample might include a vector of parameters sampled from a prior distribution.\n\nWhen sampling using sample, every step call after the first has access to the current state of the sampler.\n\n\n\n\n\n","category":"function"},{"location":"design/#Collecting-samples","page":"Design","title":"Collecting samples","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nThis section does not apply to the iterator and transducer interface.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"After the initial sample is obtained, the default implementations for regular and parallel sampling (not for the iterator and the transducer since it is not needed there) create a container for all samples (the initial one and all subsequent samples) using AbstractMCMC.samples.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"AbstractMCMC.samples","category":"page"},{"location":"design/#AbstractMCMC.samples","page":"Design","title":"AbstractMCMC.samples","text":"samples(sample, model, sampler[, N; kwargs...])\n\nGenerate a container for the samples of the MCMC sampler for the model, whose first sample is sample.\n\nThe method can be called with and without a predefined number N of samples.\n\n\n\n\n\n","category":"function"},{"location":"design/","page":"Design","title":"Design","text":"In each step, the sample is saved in the container by AbstractMCMC.save!!. The notation !! follows the convention of the package BangBang.jl which is used in the default implementation of AbstractMCMC.save!!. It indicates that the sample is pushed to the container but a \"widening\" fallback is used if the container type does not allow to save the sample. Therefore AbstractMCMC.save!! always has to return the container.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"AbstractMCMC.save!!","category":"page"},{"location":"design/#AbstractMCMC.save!!","page":"Design","title":"AbstractMCMC.save!!","text":"save!!(samples, sample, iteration, model, sampler[, N; kwargs...])\n\nSave the sample of the MCMC sampler at the current iteration in the container of samples.\n\nThe function can be called with and without a predefined number N of samples. By default, AbstractMCMC uses push!! from the Julia package BangBang to append to the container, and widen its type if needed.\n\n\n\n\n\n","category":"function"},{"location":"design/","page":"Design","title":"Design","text":"For most use cases the default implementation of AbstractMCMC.samples and AbstractMCMC.save!! should work out of the box and hence need not to be overloaded in downstream code.","category":"page"},{"location":"design/#Creating-chains","page":"Design","title":"Creating chains","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nThis section does not apply to the iterator and transducer interface.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"At the end of the sampling procedure for regular and paralle sampling we transform the collection of samples to the desired output type by calling AbstractMCMC.bundle_samples.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"AbstractMCMC.bundle_samples","category":"page"},{"location":"design/#AbstractMCMC.bundle_samples","page":"Design","title":"AbstractMCMC.bundle_samples","text":"bundle_samples(samples, model, sampler, state, chain_type[; kwargs...])\n\nBundle all samples that were sampled from the model with the given sampler in a chain.\n\nThe final state of the sampler can be included in the chain. The type of the chain can be specified with the chain_type argument.\n\nBy default, this method returns samples.\n\n\n\n\n\n","category":"function"},{"location":"design/","page":"Design","title":"Design","text":"The default implementation should be fine in most use cases, but downstream packages could, e.g., save the final state of the sampler as well if they overload AbstractMCMC.bundle_samples.","category":"page"},{"location":"#AbstractMCMC.jl","page":"Home","title":"AbstractMCMC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Abstract types and interfaces for Markov chain Monte Carlo methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractMCMC defines an interface for sampling and combining Markov chains. It comes with a default sampling algorithm that provides support of progress bars, parallel sampling (multithreaded and multicore), and user-provided callbacks out of the box. Typically developers only have to define the sampling step of their inference method in an iterator-like fashion to make use of this functionality. Additionally, the package defines an iterator and a transducer for sampling Markov chains based on the interface.","category":"page"}]
}
