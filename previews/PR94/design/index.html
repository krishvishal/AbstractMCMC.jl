<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · AbstractMCMC</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractMCMC</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Design</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-structure"><span>Basic structure</span></a></li><li><a class="tocitem" href="#Sampling-step"><span>Sampling step</span></a></li><li><a class="tocitem" href="#Collecting-samples"><span>Collecting samples</span></a></li><li><a class="tocitem" href="#Creating-chains"><span>Creating chains</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/AbstractMCMC.jl/blob/master/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Design"><a class="docs-heading-anchor" href="#Design">Design</a><a id="Design-1"></a><a class="docs-heading-anchor-permalink" href="#Design" title="Permalink"></a></h1><p>This page explains the default implementations and design choices of AbstractMCMC. It is not intended for users but for developers that want to implement the AbstractMCMC interface for Markov chain Monte Carlo sampling. The user-facing API is explained in <a href="../api/#API">API</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>AbstractMCMC provides a default implementation of the user-facing interface described in <a href="../api/#API">API</a>. You can completely neglect these and define your own implementation of the interface. However, as described below, in most use cases the default implementation allows you to obtain support of parallel sampling, progress logging, callbacks, iterators, and transducers for free by just defining the sampling step of your inference algorithm, drastically reducing the amount of code you have to write. In general, the docstrings of the functions described below might be helpful if you intend to make use of the default implementations.</p><h2 id="Basic-structure"><a class="docs-heading-anchor" href="#Basic-structure">Basic structure</a><a id="Basic-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-structure" title="Permalink"></a></h2><p>The simplified structure for regular sampling (the actual implementation contains some additional error checks and support for progress logging and callbacks) is</p><pre><code class="language-julia">StatsBase.sample(
    rng::Random.AbstractRNG,
    model::AbstractMCMC.AbstractModel,
    sampler::AbstractMCMC.AbstractSampler,
    nsamples::Integer;
    chain_type = ::Type{Any},
    kwargs...
)
    # Obtain the initial sample and state.
    sample, state = AbstractMCMC.step(rng, model, sampler; kwargs...)

    # Save the sample.
    samples = AbstractMCMC.samples(sample, model, sampler, N; kwargs...)
    samples = AbstractMCMC.save!!(samples, sample, 1, model, sampler, N; kwargs...)

    # Step through the sampler.
    for i in 2:N
        # Obtain the next sample and state.
        sample, state = AbstractMCMC.step(rng, model, sampler, state; kwargs...)

        # Save the sample.
        samples = AbstractMCMC.save!!(samples, sample, i, model, sampler, N; kwargs...)
    end

    return AbstractMCMC.bundle_samples(samples, model, sampler, state, chain_type; kwargs...)
end</code></pre><p>All other default implementations make use of the same structure and in particular call the same methods.</p><h2 id="Sampling-step"><a class="docs-heading-anchor" href="#Sampling-step">Sampling step</a><a id="Sampling-step-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-step" title="Permalink"></a></h2><p>The only method for which no default implementation is provided (and hence which downstream packages <em>have</em> to implement) is <a href="#AbstractMCMC.step"><code>AbstractMCMC.step</code></a>. It defines the sampling step of the inference method.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractMCMC.step" href="#AbstractMCMC.step"><code>AbstractMCMC.step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step(rng, model, sampler[, state; kwargs...])</code></pre><p>Return a 2-tuple of the next sample and the next state of the MCMC <code>sampler</code> for <code>model</code>.</p><p>Samples describe the results of a single step of the <code>sampler</code>. As an example, a sample might include a vector of parameters sampled from a prior distribution.</p><p>When sampling using <a href="../api/#StatsBase.sample-Tuple{AbstractRNG, AbstractMCMC.AbstractModel, AbstractMCMC.AbstractSampler, Integer}"><code>sample</code></a>, every <code>step</code> call after the first has access to the current <code>state</code> of the sampler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractMCMC.jl/blob/381634ddaa07fec7c28e1a7729a2c07f38349c2a/src/interface.jl#L56-L66">source</a></section></article><h2 id="Collecting-samples"><a class="docs-heading-anchor" href="#Collecting-samples">Collecting samples</a><a id="Collecting-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-samples" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This section does not apply to the iterator and transducer interface.</p></div></div><p>After the initial sample is obtained, the default implementations for regular and parallel sampling (not for the iterator and the transducer since it is not needed there) create a container for all samples (the initial one and all subsequent samples) using <code>AbstractMCMC.samples</code>.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractMCMC.samples" href="#AbstractMCMC.samples"><code>AbstractMCMC.samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samples(sample, model, sampler[, N; kwargs...])</code></pre><p>Generate a container for the samples of the MCMC <code>sampler</code> for the <code>model</code>, whose first sample is <code>sample</code>.</p><p>The method can be called with and without a predefined number <code>N</code> of samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractMCMC.jl/blob/381634ddaa07fec7c28e1a7729a2c07f38349c2a/src/interface.jl#L69-L76">source</a></section></article><p>In each step, the sample is saved in the container by <code>AbstractMCMC.save!!</code>. The notation <code>!!</code> follows the convention of the package <a href="https://github.com/JuliaFolds/BangBang.jl">BangBang.jl</a> which is used in the default implementation of <code>AbstractMCMC.save!!</code>. It indicates that the sample is pushed to the container but a &quot;widening&quot; fallback is used if the container type does not allow to save the sample. Therefore <code>AbstractMCMC.save!!</code> <em>always has</em> to return the container.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractMCMC.save!!" href="#AbstractMCMC.save!!"><code>AbstractMCMC.save!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save!!(samples, sample, iteration, model, sampler[, N; kwargs...])</code></pre><p>Save the <code>sample</code> of the MCMC <code>sampler</code> at the current <code>iteration</code> in the container of <code>samples</code>.</p><p>The function can be called with and without a predefined number <code>N</code> of samples. By default, AbstractMCMC uses <code>push!!</code> from the Julia package <a href="https://github.com/tkf/BangBang.jl">BangBang</a> to append to the container, and widen its type if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractMCMC.jl/blob/381634ddaa07fec7c28e1a7729a2c07f38349c2a/src/interface.jl#L98-L108">source</a></section></article><p>For most use cases the default implementation of <code>AbstractMCMC.samples</code> and <code>AbstractMCMC.save!!</code> should work out of the box and hence need not to be overloaded in downstream code.</p><h2 id="Creating-chains"><a class="docs-heading-anchor" href="#Creating-chains">Creating chains</a><a id="Creating-chains-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-chains" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This section does not apply to the iterator and transducer interface.</p></div></div><p>At the end of the sampling procedure for regular and paralle sampling we transform the collection of samples to the desired output type by calling <code>AbstractMCMC.bundle_samples</code>.</p><article class="docstring"><header><a class="docstring-binding" id="AbstractMCMC.bundle_samples" href="#AbstractMCMC.bundle_samples"><code>AbstractMCMC.bundle_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bundle_samples(samples, model, sampler, state, chain_type[; kwargs...])</code></pre><p>Bundle all <code>samples</code> that were sampled from the <code>model</code> with the given <code>sampler</code> in a chain.</p><p>The final <code>state</code> of the <code>sampler</code> can be included in the chain. The type of the chain can be specified with the <code>chain_type</code> argument.</p><p>By default, this method returns <code>samples</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/AbstractMCMC.jl/blob/381634ddaa07fec7c28e1a7729a2c07f38349c2a/src/interface.jl#L22-L31">source</a></section></article><p>The default implementation should be fine in most use cases, but downstream packages could, e.g., save the final state of the sampler as well if they overload <code>AbstractMCMC.bundle_samples</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Thursday 10 February 2022 00:51">Thursday 10 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
